#!/usr/bin/env python
# Usage: fixwinsz WIDTH[xHEIGHT] [--] COMMAND [ARGS]...
# Run COMMAND in a pty restricted to WIDTHxHEIGHT dimensions.
#
# XXX: snoop and apply/emulate DECSTBM/CSR?

import os
import sys
import pty
import re
import time
import argparse
import struct
import fcntl
import errno
import ctypes
import ctypes.util
import termios
import atexit
import signal
import threading


def getwinsz(fd: int = sys.stdout.fileno()):
    """
    Return size (LINES, COLUMNS) of the tty associated with the descriptor.
    """
    s = struct.pack('HHHH', 0, 0, 0, 0)
    s = struct.unpack('HHHH', fcntl.ioctl(fd, termios.TIOCGWINSZ, s))
    return (s[0], s[1])


def forkpty(width: int, height: int):
    """
    Return (pid, master, name)
    """
    class winsize(ctypes.Structure):
        _fields_ = [
            ('ws_row', ctypes.c_ushort),
            ('ws_col', ctypes.c_ushort),
            ('ws_xpixel', ctypes.c_ushort),
            ('ws_ypixel', ctypes.c_ushort)
        ]

    max_ushort = 2 ** (ctypes.sizeof(ctypes.c_ushort) * 8) - 1

    if (not isinstance(width, int)):
        raise ValueError("width is not an int")
    if width < 0 or width > max_ushort:
        raise ValueError("width overflows unsigned short")
    if (not isinstance(height, int)):
        raise ValueError("width is not an int")
    if height < 0 or height > max_ushort:
        raise ValueError("height overflows unsigned short")

    libutil = ctypes.CDLL(ctypes.util.find_library('util'))
    _forkpty = libutil.forkpty
    _forkpty.restype = ctypes.c_int
    _forkpty.argtypes = [
        ctypes.POINTER(ctypes.c_int),
        ctypes.c_char_p,
        ctypes.c_char_p, # Don't use the termios arg
        ctypes.POINTER(winsize)
    ]

    ws = winsize()
    ws.ws_col = ctypes.c_ushort(width)
    ws.ws_row = ctypes.c_ushort(height)
    ws.xpixel = ctypes.c_ushort(0)
    ws.ypixel = ctypes.c_ushort(0)
    master = ctypes.c_int()
    name = ctypes.create_string_buffer(1024)

    pid = _forkpty(master, name, None, ws)
    return (pid, master.value, name.value)


def copy_nonblock(fd1, fd2, size=1024):
    try:
        data = os.read(fd1, 1024)
        os.write(fd2, data)
    except (BlockingIOError, OSError):
        pass


if __name__ == '__main__':
    class Formatter(argparse.HelpFormatter):
        def _format_usage(self, usage, actions, groups, prefix):
            if prefix is None:
                prefix = "Usage: "
            return super()._format_usage(usage, actions, groups, prefix).rstrip() + "\n"

    a = argparse.ArgumentParser(
        description="Launch command in a resized pty.",
        usage="fixwinsz WIDTH[xHEIGHT] [--] COMMAND...",
        formatter_class=Formatter,
        add_help=False)
    a.add_argument('dim', metavar='DIM', type=str, help=argparse.SUPPRESS)
    a.add_argument('--help', action='help', help=argparse.SUPPRESS)
    a.add_argument('--version', action='version', version='%(prog)s 0.10', help=argparse.SUPPRESS)
    (args, cmd) = a.parse_known_args()
    dim = args.dim.strip()

    if len(cmd) == 0:
        a.print_usage()
        sys.exit(1)

    try:
        d = re.search(r'^(?P<width>\d+)([ x:,]+(?P<height>\d+)?)?$', dim).groupdict()
    except:
        sys.stderr.write("fixwinsz: Incorrect tty size format: {}\n".format(repr(dim)))
        sys.exit(1)

    ph, pw = getwinsz()
    width = int(d['width'])
    height = int(d['height'] if d['height'] is not None else ph)

    if width <= 0 or height <= 0:
        sys.stderr.write("fixwinsz: Incorrect tty size: {}x{}\n".format(width, height))
        sys.exit(1)

    (eread, ewrite) = os.pipe2(os.O_NONBLOCK)
    (pid, master, name) = forkpty(width, height)

    os.set_inheritable(eread, True)
    os.set_inheritable(ewrite, True)
    os.set_inheritable(master, True)

    if pid == 0:
        os.dup2(ewrite, sys.stderr.fileno())
        os.execvp(cmd[0], cmd)
    else:
        flags = fcntl.fcntl(sys.stdin.fileno(), fcntl.F_GETFL, 0)
        fcntl.fcntl(sys.stdin.fileno(), fcntl.F_SETFL, flags | os.O_NONBLOCK)
        flags = fcntl.fcntl(master, fcntl.F_GETFL, 0)
        fcntl.fcntl(master, fcntl.F_SETFL, flags | os.O_NONBLOCK)

        tios = termios.tcgetattr(sys.stdin.fileno())
        tios_lflag = tios[3]
        tios[3] = tios[3] & ~termios.ICANON & ~termios.ECHO & ~termios.ISIG
        termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, tios)

        def cleanup():
            tios[3] = tios_lflag
            termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, tios)
        atexit.register(cleanup)

        exiting = False
        lk = threading.Lock()

        def updateloop():
            while True:
                with lk:
                    if exiting: break
                copy_nonblock(master, sys.stdout.fileno())
                copy_nonblock(sys.stdin.fileno(), master)
                copy_nonblock(eread, sys.stderr.fileno())
        t = threading.Thread(target=updateloop)
        t.start()

        (wpid, wstatus) = os.waitpid(pid, 0)
        if wpid:
            rc = os.WEXITSTATUS(wstatus) if os.WIFEXITED(wstatus) else 1
            with lk:
                exiting = True
            t.join()
            sys.exit(rc)
