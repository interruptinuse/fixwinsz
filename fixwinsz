#!/usr/bin/env python3
# Usage: fixwinsz [-W] WIDTH[xHEIGHT] [--] COMMAND [ARGS]...
# Run COMMAND in a pty restricted to WIDTHxHEIGHT dimensions.
#
# XXX: snoop and apply/emulate DECSTBM/CSR?

import os
import sys
import pty
import re
import time
import argparse
import struct
import fcntl
import select
import errno
import ctypes
import ctypes.util
import termios
import atexit
import signal
import threading


def getwinsz(fd: int = sys.stdout.fileno()):
    """
    Return size (LINES, COLUMNS) of the tty associated with the descriptor.
    """
    s = struct.pack('HHHH', 0, 0, 0, 0)
    s = struct.unpack('HHHH', fcntl.ioctl(fd, termios.TIOCGWINSZ, s))
    return (s[0], s[1])


def setwinsz(width: int, height: int, fd: int):
    fcntl.ioctl(fd, termios.TIOCSWINSZ, struct.pack('HHHH', height, width, 0, 0))


def forkpty(width: int, height: int):
    """
    Return (pid, master, name)
    """
    class winsize(ctypes.Structure):
        _fields_ = [
            ('ws_row', ctypes.c_ushort),
            ('ws_col', ctypes.c_ushort),
            ('ws_xpixel', ctypes.c_ushort),
            ('ws_ypixel', ctypes.c_ushort)
        ]

    max_ushort = 2 ** (ctypes.sizeof(ctypes.c_ushort) * 8) - 1

    if (not isinstance(width, int)):
        raise ValueError("width is not an int")
    if width < 0 or width > max_ushort:
        raise ValueError("width overflows unsigned short")
    if (not isinstance(height, int)):
        raise ValueError("width is not an int")
    if height < 0 or height > max_ushort:
        raise ValueError("height overflows unsigned short")

    libutil = ctypes.CDLL(ctypes.util.find_library('util'))
    _forkpty = libutil.forkpty
    _forkpty.restype = ctypes.c_int
    _forkpty.argtypes = [
        ctypes.POINTER(ctypes.c_int),
        ctypes.c_char_p,
        ctypes.c_char_p, # Don't use the termios arg
        ctypes.POINTER(winsize)
    ]

    ws = winsize()
    ws.ws_col = ctypes.c_ushort(width)
    ws.ws_row = ctypes.c_ushort(height)
    ws.xpixel = ctypes.c_ushort(0)
    ws.ypixel = ctypes.c_ushort(0)
    master = ctypes.c_int()
    name = ctypes.create_string_buffer(1024)

    pid = _forkpty(master, name, None, ws)
    return (pid, master.value, name.value)


class PollingForwarder:
    def __init__(self):
        self.ifds = {}
        self.ofds = set()
        self.ipoll = select.poll()
        self.opoll = select.poll()

    def map(self, fdi, fdo):
        self.ifds[fdi] = fdo
        self.ofds.add(fdo)
        self.ipoll.register(fdi, select.POLLIN)
        self.opoll.register(fdo, select.POLLOUT)

    def forward(self, timeout=1):
        oevents = set()
        oevents.update(fd for fd, event in self.opoll.poll(timeout))
        ievents = self.ipoll.poll(timeout)

        for (fdi, event) in ievents:
            fdo = self.ifds[fdi]
            if fdo in oevents:
                try:
                    data = os.read(fdi, 1024)
                    os.write(fdo, data)
                except OSError:
                    pass


if __name__ == '__main__':
    class Formatter(argparse.HelpFormatter):
        def _format_usage(self, usage, actions, groups, prefix):
            if prefix is None:
                prefix = "Usage: "
            return super()._format_usage(usage, actions, groups, prefix).rstrip() + "\n"

    a = argparse.ArgumentParser(
        description="Launch command in a resized pty.",
        usage="fixwinsz [-W] WIDTH[xHEIGHT] [--] COMMAND...",
        formatter_class=Formatter,
        add_help=False)
    a.add_argument('dim', metavar='WIDTH[xHEIGHT]', type=str, help=argparse.SUPPRESS)
    a.add_argument('cmd', metavar='COMMAND...', type=str, nargs=argparse.REMAINDER, help=argparse.SUPPRESS)
    a.add_argument('-W', dest='winch', action='store_false', help="Ignore parent SIGWINCH when HEIGHT unspecified")
    a.add_argument('--help', action='help', help=argparse.SUPPRESS)
    a.add_argument('--version', action='version', version='%(prog)s 0.10', help=argparse.SUPPRESS)
    a._optionals.title = "Optional arguments"
    a.set_defaults(winch=True)
    args = a.parse_args()
    dim = args.dim.strip()
    cmd = args.cmd

    if len(cmd) == 0:
        a.print_usage()
        sys.exit(1)

    try:
        d = re.search(r'^(?P<width>\d+)([ x:,]+(?P<height>\d+)?)?$', dim).groupdict()
    except:
        sys.stderr.write("fixwinsz: Incorrect tty size format: {}\n".format(repr(dim)))
        sys.exit(1)

    ph, pw = getwinsz()
    width = int(d['width'])
    height = int(d['height'] if d['height'] is not None else ph)

    if width <= 0 or height <= 0:
        sys.stderr.write("fixwinsz: Incorrect tty size: {}x{}\n".format(width, height))
        sys.exit(1)

    (eread, ewrite) = os.pipe2(os.O_NONBLOCK)
    (pid, master, name) = forkpty(width, height)

    os.set_inheritable(eread, True)
    os.set_inheritable(ewrite, True)
    os.set_inheritable(master, True)

    if pid == 0:
        os.dup2(ewrite, sys.stderr.fileno())
        os.execvp(cmd[0], cmd)
    else:
        if args.winch and 'height' in d:
            def sigwinch(sig, frame):
                newheight, newwidth = getwinsz()
                setwinsz(width, newheight, master)
            signal.signal(signal.SIGWINCH, sigwinch)

        tios = termios.tcgetattr(sys.stdin.fileno())
        tios_lflag = tios[3]
        tios[3] = tios[3] & ~termios.ICANON & ~termios.ECHO & ~termios.ISIG
        termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, tios)

        def cleanup():
            tios[3] = tios_lflag
            termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, tios)
        atexit.register(cleanup)

        exiting = False
        lk = threading.Lock()

        def updateloop():
            fwd = PollingForwarder()
            fwd.map(master, 1)
            fwd.map(0, master)
            fwd.map(eread, 2)

            while True:
                fwd.forward()
                with lk:
                    if exiting: break
        t = threading.Thread(target=updateloop)
        t.start()

        (wpid, wstatus) = os.waitpid(pid, 0)
        if wpid:
            rc = os.WEXITSTATUS(wstatus) if os.WIFEXITED(wstatus) else 1
            with lk:
                exiting = True
            t.join()
            sys.exit(rc)
