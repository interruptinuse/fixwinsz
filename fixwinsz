#!/usr/bin/env python
# Usage: fixwinsz WIDTH[xHEIGHT] [--] COMMAND [ARGS]...
# Run COMMAND in a pty restricted to WIDTHxHEIGHT dimensions.
#
# XXX: snoop and apply/emulate DECSTBM/CSR?

import os
import sys
import pty
import re
import time
import argparse
import struct
import fcntl
import errno
import ctypes
import ctypes.util
import termios


def getwinsz(fd: int = sys.stdout.fileno()):
    """
    Return size (LINES, COLUMNS) of the tty associated with the descriptor.
    """
    s = struct.pack('HHHH', 0, 0, 0, 0)
    s = struct.unpack('HHHH', fcntl.ioctl(fd, termios.TIOCGWINSZ, s))
    return (s[0], s[1])


def forkpty(width: int, height: int):
    """
    Return (pid, master, name)
    """
    class winsize(ctypes.Structure):
        _fields_ = [
            ('ws_row', ctypes.c_ushort),
            ('ws_col', ctypes.c_ushort),
            ('ws_xpixel', ctypes.c_ushort),
            ('ws_ypixel', ctypes.c_ushort)
        ]

    max_ushort = 2 ** (ctypes.sizeof(ctypes.c_ushort) * 8) - 1

    if (not isinstance(width, int)):
        raise ValueError("width is not an int")
    if width < 0 or width > max_ushort:
        raise ValueError("width overflows unsigned short")
    if (not isinstance(height, int)):
        raise ValueError("width is not an int")
    if height < 0 or height > max_ushort:
        raise ValueError("height overflows unsigned short")

    libutil = ctypes.CDLL(ctypes.util.find_library('util'))
    _forkpty = libutil.forkpty
    _forkpty.restype = ctypes.c_int
    _forkpty.argtypes = [
        ctypes.POINTER(ctypes.c_int),
        ctypes.c_char_p,
        ctypes.c_char_p, # Don't use the termios arg
        ctypes.POINTER(winsize)
    ]

    ws = winsize()
    ws.ws_col = ctypes.c_ushort(width)
    ws.ws_row = ctypes.c_ushort(height)
    ws.xpixel = ctypes.c_ushort(0)
    ws.ypixel = ctypes.c_ushort(0)
    master = ctypes.c_int()
    name = ctypes.create_string_buffer(1024)

    pid = _forkpty(master, name, None, ws)
    return (pid, master.value, name.value)


if __name__ == '__main__':
    class Formatter(argparse.HelpFormatter):
        def _format_usage(self, usage, actions, groups, prefix):
            if prefix is None:
                prefix = 'Usage: '
            return super()._format_usage(usage, actions, groups, prefix).rstrip() + "\n"

    a = argparse.ArgumentParser(
        description='Launch command in a resized pty.',
        usage='fixwinsz WIDTH[xHEIGHT] [--] COMMAND...',
        formatter_class=Formatter,
        add_help=False)
    a.add_argument('dim', metavar='DIM', type=str, help=argparse.SUPPRESS)
    a.add_argument('--help', action='help', help=argparse.SUPPRESS)
    a.add_argument('--version', action='version', version="%(prog)s 0.10", help=argparse.SUPPRESS)
    (args, cmd) = a.parse_known_args()
    dim = args.dim.strip()

    try:
        d = re.search(r'^(?P<width>\d+)([ x:,]+(?P<height>\d+)?)?$', dim).groupdict()
    except:
        sys.stderr.write("fixwinsz: Incorrect tty size format: {}\n".format(repr(dim)))
        sys.exit(1)

    ph, pw = getwinsz()

    locals().update(d)
    width = int(width)
    height = int(height) if height else ph

    if width <= 0 or height <= 0:
        sys.stderr.write("fixwinsz: Incorrect tty size: {}x{}\n".format(width, height))
        sys.exit(1)

    (eread, ewrite) = os.pipe2(os.O_NONBLOCK)
    (pid, master, name) = forkpty(width, height)

    os.set_inheritable(eread, True)
    os.set_inheritable(ewrite, True)
    os.set_inheritable(master, True)

    if pid == 0:
        os.dup2(ewrite, sys.stderr.fileno())
        os.execvp(cmd[0], cmd)
    else:
        os.set_inheritable(master, True)
        os.set_inheritable(eread, True)

        if os.fork():
            sys.stdin.close()
            sys.stdout.close()
            (wpid, wstatus) = os.waitpid(pid, 0)
            if wpid:
                rc = os.WEXITSTATUS(wstatus) if os.WIFEXITED(wstatus) else 1
                sys.exit(rc)
        else:
            flags = fcntl.fcntl(sys.stdin.fileno(), fcntl.F_GETFL, 0)
            fcntl.fcntl(sys.stdin.fileno(), fcntl.F_SETFL, flags | os.O_NONBLOCK)
            flags = fcntl.fcntl(master, fcntl.F_GETFL, 0)
            fcntl.fcntl(master, fcntl.F_SETFL, flags | os.O_NONBLOCK)

            tios = termios.tcgetattr(sys.stdin.fileno())
            tios_lflag = tios[3]
            tios[3] = tios[3] & ~termios.ICANON & ~termios.ECHO & ~termios.ISIG
            termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, tios)

            while True:
                try:
                    data = os.read(master, 1024)
                    os.write(sys.stdout.fileno(), data)
                except BlockingIOError:
                    pass
                except OSError:
                    break

                try:
                    data = os.read(sys.stdin.fileno(), 1024)
                    os.write(master, data)
                except BlockingIOError:
                    pass
                except OSError:
                    break

                try:
                    data = os.read(eread, 1024)
                    os.write(sys.stderr.fileno(), data)
                except BlockingIOError:
                    pass
                except OSError:
                    break

            tios[3] = tios_lflag
            termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, tios)
