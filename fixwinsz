#!/usr/bin/env python3
# Usage: fixwinsz [-W] WIDTH[xHEIGHT] [--] COMMAND [ARGS]...
# Run COMMAND in a pty restricted to WIDTHxHEIGHT dimensions.
#
# XXX: snoop and apply/emulate DECSTBM/CSR?

import os
import sys
import pty
import re
import time
import argparse
import struct
import fcntl
import select
import errno
import ctypes
import ctypes.util
import termios
import atexit
import signal
import threading


STDIN_FILENO = sys.stdin.fileno()
STDOUT_FILENO = sys.stdout.fileno()
STDERR_FILENO = sys.stderr.fileno()


def getwinsz(fd: int = STDOUT_FILENO):
    """
    Return size (LINES, COLUMNS) of the tty associated with the descriptor.
    """
    s = struct.pack('HHHH', 0, 0, 0, 0)
    try:
        s = struct.unpack('HHHH', fcntl.ioctl(fd, termios.TIOCGWINSZ, s))
        return (s[0], s[1])
    except OSError as e:
        if e.args[0] == errno.ENOTTY:
            return (None, None)


def setwinsz(width: int, height: int, *fds):
    for fd in fds:
        fcntl.ioctl(fd, termios.TIOCSWINSZ, struct.pack('HHHH', height, width, 0, 0))


def openpty(width: int, height: int):
    """
    Return (result, amaster, aslave, name)
    """
    class winsize(ctypes.Structure):
        _fields_ = [
            ('ws_row', ctypes.c_ushort),
            ('ws_col', ctypes.c_ushort),
            ('ws_xpixel', ctypes.c_ushort),
            ('ws_ypixel', ctypes.c_ushort)
        ]

    max_ushort = 2 ** (ctypes.sizeof(ctypes.c_ushort) * 8) - 1

    if (not isinstance(width, int)):
        raise ValueError("width is not an int")
    if width < 0 or width > max_ushort:
        raise ValueError("width overflows unsigned short")
    if (not isinstance(height, int)):
        raise ValueError("width is not an int")
    if height < 0 or height > max_ushort:
        raise ValueError("height overflows unsigned short")

    libutil = ctypes.CDLL(ctypes.util.find_library('util'), use_errno=True)
    _openpty = libutil.openpty
    _openpty.restype = ctypes.c_int
    _openpty.argtypes = [
        ctypes.POINTER(ctypes.c_int),
        ctypes.POINTER(ctypes.c_int),
        ctypes.c_char_p,
        ctypes.c_char_p, # Don't use the termios arg
        ctypes.POINTER(winsize)
    ]

    ws = winsize()
    ws.ws_col = ctypes.c_ushort(width)
    ws.ws_row = ctypes.c_ushort(height)
    ws.xpixel = ctypes.c_ushort(0)
    ws.ypixel = ctypes.c_ushort(0)
    amaster = ctypes.c_int()
    aslave = ctypes.c_int()
    name = ctypes.create_string_buffer(4096)

    result = _openpty(amaster, aslave, name, None, ws)
    return (result, amaster.value, aslave.value, name.value)


class PollingForwarder:
    def __init__(self):
        self.ifds = {}
        self.ofds = set()
        self.ipoll = select.poll()
        self.opoll = select.poll()

    def map(self, fdi, fdo):
        self.ifds[fdi] = fdo
        self.ofds.add(fdo)
        self.ipoll.register(fdi, select.POLLIN)
        self.opoll.register(fdo, select.POLLOUT)

    def forward(self, timeout=1):
        oevents = set()
        oevents.update(fd for fd, event in self.opoll.poll(timeout))
        ievents = self.ipoll.poll(timeout)

        for (fdi, event) in ievents:
            fdo = self.ifds[fdi]
            if fdo in oevents:
                try:
                    data = os.read(fdi, 1024)
                    os.write(fdo, data)
                except OSError:
                    pass


if __name__ == '__main__':
    def excepthook(errtype, value, traceback):
        if issubclass(errtype, KeyboardInterrupt):
            return
        ln = traceback.tb_lineno
        et = errtype.__name__
        sys.stderr.write("fixwinsz[{}]: FATAL: {}: ".format(ln, et))
        args = value.args
        if 'format' in dir(args[0]):
            estr = args[0].format(*args[1:])
        else:
            estr = "{!r}".format(args)
        sys.stderr.write(estr.strip())
        sys.stderr.write("\n")
        sys.stderr.flush()
        sys.exit(1)
    sys.excepthook = excepthook

    class Formatter(argparse.HelpFormatter):
        def _format_usage(self, usage, actions, groups, prefix):
            if prefix is None:
                prefix = "Usage: "
            return super()._format_usage(usage, actions, groups, prefix).rstrip() + "\n"

    a = argparse.ArgumentParser(
        description="Launch command in a resized pty.",
        usage="fixwinsz [-W] WIDTH[xHEIGHT] [--] COMMAND...",
        formatter_class=Formatter,
        add_help=False)
    a.add_argument('dim', metavar='WIDTH[xHEIGHT]', type=str, help=argparse.SUPPRESS)
    a.add_argument('cmd', metavar='COMMAND...', type=str, nargs=argparse.REMAINDER, help=argparse.SUPPRESS)
    a.add_argument('-W', dest='winch', action='store_false', help="Ignore parent SIGWINCH when HEIGHT unspecified")
    a.add_argument('--stderr', dest='stderr', metavar='PTY|FIFO|MUX|DETECT|DISCARD', type=str.upper, choices=['PTY', 'FIFO', 'MUX', 'DETECT', 'DISCARD'], default='DETECT', help="Handle COMMAND's stderr (see fixwinsz(1))")
    a.add_argument('--help', action='help', help=argparse.SUPPRESS)
    a.add_argument('--version', action='version', version='%(prog)s 0.10', help=argparse.SUPPRESS)
    a._optionals.title = "Optional arguments"
    a.set_defaults(winch=True)
    args = a.parse_args()
    dim = args.dim.strip()
    cmd = args.cmd

    if len(cmd) == 0:
        a.print_usage()
        sys.exit(1)

    try:
        d = re.search(r'^(?P<width>\d+)([ x:,]+(?P<height>\d+)?)?$', dim).groupdict()
    except:
        raise ValueError("Incorrect tty size format: {!r}", dim)

    ph, pw = getwinsz()
    width = int(d['width'])
    height = int(d['height'] if d['height'] is not None else ph)

    if width <= 0 or height <= 0:
        raise ValueError("Incorrect tty size: {}x{}", width, height)

    result, amaster, aslave, name = openpty(width, height)
    if result != 0:
        raise OSError("openpty(3) failed: {}", os.strerror(ctypes.get_errno()))

    if os.isatty(STDIN_FILENO):
        stdin_read, stdin_write = aslave, amaster
    else:
        stdin_read, stdin_write = os.pipe()

    if os.isatty(STDOUT_FILENO):
        stdout_read, stdout_write = amaster, aslave
    else:
        stdout_read, stdout_write = os.pipe()

    if args.stderr == 'DETECT':
        args.stderr = 'PTY' if os.isatty(STDERR_FILENO) else 'FIFO'

    stderr_read = stderr_write = None
    eresult = emaster = eslave = ename = None
    if   args.stderr == 'PTY':
        eresult, emaster, eslave, ename = openpty(width, height)
        if eresult != 0:
            raise OSError("openpty(3) failed: {}", os.strerror(ctypes.get_errno()))
        stderr_read, stderr_write = emaster, eslave
    elif args.stderr in ['FIFO', 'DISCARD']:
        stderr_read, stderr_write = os.pipe()
    elif args.stderr == 'MUX':
        stderr_read, stderr_write = None, aslave
    else:
        raise ValueError("Illegal value for args.stderr: {!r}", args.stderr)

    inheritables  = []
    inheritables += [stdin_read, stdin_write]
    inheritables += [stdout_read, stdout_write]
    inheritables += [stderr_read, stderr_write]
    inheritables += [amaster, aslave]
    for fd in filter(lambda fd: fd is not None, inheritables):
        os.set_inheritable(fd, True)

    pid = os.fork()

    if pid == 0:
        os.setsid()
        fcntl.ioctl(aslave, termios.TIOCSCTTY)

        os.dup2(stdin_read, STDIN_FILENO)
        os.dup2(stdout_write, STDOUT_FILENO)
        os.dup2(stderr_write, STDERR_FILENO)

        for fd in [amaster, aslave, emaster, eslave, stdin_read, stdin_write,
                   stdout_read, stdout_write, stderr_read, stderr_write]:
            if fd is None: continue
            try:
                os.close(fd)
            except OSError as e:
                if e.args[0] != errno.EBADF:
                    raise
        os.execvp(cmd[0], cmd)
    else:
        if args.winch and d.get('height', None) is None:
            winsz_fds = [amaster]
            if args.stderr == 'PTY':
                winsz_fds += [stderr_read]
            def sigwinch(sig, frame):
                newheight, newwidth = getwinsz()
                setwinsz(width, newheight, *winsz_fds)
            signal.signal(signal.SIGWINCH, sigwinch)

        tios = termios.tcgetattr(STDIN_FILENO)
        tios_lflag = tios[3]
        tios[3] = tios[3] & ~termios.ICANON & ~termios.ECHO & ~termios.ISIG
        termios.tcsetattr(STDIN_FILENO, termios.TCSANOW, tios)

        def cleanup():
            tios[3] = tios_lflag
            termios.tcsetattr(STDIN_FILENO, termios.TCSANOW, tios)
        atexit.register(cleanup)

        exiting = False
        lk = threading.Lock()

        def updateloop():
            fwd = PollingForwarder()
            fwd.map(STDIN_FILENO, stdin_write)
            fwd.map(stdout_read, STDOUT_FILENO)
            if   args.stderr == 'MUX':
                pass
            elif args.stderr == 'DISCARD':
                devnull = os.open(os.devnull, os.O_WRONLY)
                fwd.map(stderr_read, devnull)
            else:
                fwd.map(stderr_read, STDERR_FILENO)

            while True:
                fwd.forward()
                with lk:
                    if exiting: break
        t = threading.Thread(target=updateloop)
        t.start()

        (wpid, wstatus) = os.waitpid(pid, 0)
        if wpid:
            rc = os.WEXITSTATUS(wstatus) if os.WIFEXITED(wstatus) else 1
            with lk:
                exiting = True
            t.join()
            sys.exit(rc)
